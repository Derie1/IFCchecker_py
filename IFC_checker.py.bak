import time
import os
import logging
import argparse
import hashlib
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from datetime import datetime

# Словарь сообщений для разных языков
MESSAGES = {
    "en": {
        "new": "[NEW] File created: {}",
        "updated": "[UPDATED] File modified: {}",
        "deleted": "[DELETED] File deleted: {}",
        "monitoring": "Monitoring folder: {}",
        "error": "Error: {} is not a valid directory",
        "start": "=== Monitoring started at {} ===\nFolder: {}"
    },
    "ru": {
        "new": "[НОВЫЙ] Файл создан: {}",
        "updated": "[ИЗМЕНЁН] Файл изменён: {}",
        "deleted": "[УДАЛЁН] Файл удалён: {}",
        "monitoring": "Мониторинг папки: {}",
        "error": "Ошибка: {} не является папкой",
        "start": "=== Мониторинг запущен в {} ===\nПапка: {}"
    },
    "de": {
        "new": "[NEU] Datei erstellt: {}",
        "updated": "[AKTUALISIERT] Datei geändert: {}",
        "deleted": "[GELÖSCHT] Datei gelöscht: {}",
        "monitoring": "Überwachung des Ordners: {}",
        "error": "Fehler: {} ist kein gültiges Verzeichnis",
        "start": "=== Überwachung gestartet am {} ===\nOrdner: {}"
    }
}


class IFCFileHandler(FileSystemEventHandler):
    def __init__(self, lang="en", base_folder=""):
        self.lang = lang if lang in MESSAGES else "en"
        self.file_hashes = {}  # словарь: путь -> хэш
        self.base_folder = os.path.abspath(base_folder)

    def relative_path(self, full_path):
        try:
            rel = os.path.relpath(full_path, self.base_folder)
            return "\\" + rel.replace("/", "\\")
        except Exception:
            return full_path

    def log_message(self, key, path):
        rel_path = self.relative_path(path)
        msg = MESSAGES[self.lang][key].format(rel_path)
        print(f"{datetime.now():%Y-%m-%d %H:%M:%S} {msg}")
        logging.info(msg)

    def get_file_hash(self, path):
        try:
            with open(path, "rb") as f:
                return hashlib.md5(f.read()).hexdigest()
        except Exception:
            return None

    def on_created(self, event):
        if not event.is_directory and event.src_path.lower().endswith(".ifc"):
            file_hash = self.get_file_hash(event.src_path)
            if file_hash:
                self.file_hashes[event.src_path] = file_hash
            self.log_message("new", event.src_path)

    def on_modified(self, event):
        if not event.is_directory and event.src_path.lower().endswith(".ifc"):
            new_hash = self.get_file_hash(event.src_path)
            old_hash = self.file_hashes.get(event.src_path)
            if new_hash and new_hash != old_hash:
                self.file_hashes[event.src_path] = new_hash
                self.log_message("updated", event.src_path)

    def on_deleted(self, event):
        if not event.is_directory and event.src_path.lower().endswith(".ifc"):
            if event.src_path in self.file_hashes:
                del self.file_hashes[event.src_path]
            self.log_message("deleted", event.src_path)


def monitor_folder(path_to_watch, lang="en"):
    event_handler = IFCFileHandler(lang, path_to_watch)
    observer = Observer()
    observer.schedule(event_handler, path=path_to_watch, recursive=True)
    observer.start()
    print(MESSAGES[lang]["monitoring"].format(path_to_watch))

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="IFC files monitoring tool")
    parser.add_argument("folder", help="Path to the folder to monitor")
    parser.add_argument("--lang", choices=["en", "ru", "de"], default="en",
                        help="Language for messages (default: en)")
    args = parser.parse_args()

    if not os.path.isdir(args.folder):
        print(MESSAGES[args.lang]["error"].format(args.folder))
    else:
        # Заголовок в лог-файле
        with open("ifc_monitor.log", "a", encoding="utf-8") as f:
            f.write("\n")
            f.write(MESSAGES[args.lang]["start"].format(
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                os.path.abspath(args.folder)
            ) + "\n")

        # Настройка логирования
        logging.basicConfig(
            filename="ifc_monitor.log",
            level=logging.INFO,
            format="%(asctime)s - %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S"
        )

        monitor_folder(args.folder, args.lang)
